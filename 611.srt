

1
00:00:12.016 --> 00:00:13.736 A:middle
[ Applause ]

2
00:00:13.736 --> 00:00:14.316 A:middle
&gt;&gt; Thank you.

3
00:00:15.866 --> 00:00:16.286 A:middle
Thank you.

4
00:00:16.286 --> 00:00:17.586 A:middle
Good morning, good morning.

5
00:00:17.586 --> 00:00:18.216 A:middle
And welcome.

6
00:00:18.896 --> 00:00:21.986 A:middle
You know, I love games.

7
00:00:22.766 --> 00:00:24.526 A:middle
I've been playing
them my whole life.

8
00:00:24.526 --> 00:00:26.116 A:middle
I love making games.

9
00:00:26.646 --> 00:00:28.156 A:middle
I love teaching about games.

10
00:00:28.756 --> 00:00:30.996 A:middle
And I'm really excited
to talk to you today

11
00:00:31.226 --> 00:00:33.246 A:middle
about designing for
game controllers.

12
00:00:34.166 --> 00:00:37.966 A:middle
My name is JJ Cwik, and
I'm a software engineer

13
00:00:38.146 --> 00:00:39.746 A:middle
on the Game Play Technology Team

14
00:00:39.996 --> 00:00:41.736 A:middle
or on the Game Technology
Team at Apple.

15
00:00:41.736 --> 00:00:45.766 A:middle
Now, let me poll the audience.

16
00:00:46.246 --> 00:00:49.276 A:middle
How many of you have already
integrated game controllers

17
00:00:49.446 --> 00:00:50.256 A:middle
into a game before?

18
00:00:50.956 --> 00:00:52.906 A:middle
All right, a few.

19
00:00:52.906 --> 00:00:55.606 A:middle
Great. And for how many

20
00:00:55.606 --> 00:00:58.246 A:middle
of you will this be your first
talk on game controllers?

21
00:00:59.996 --> 00:01:01.216 A:middle
Good. Large majority.

22
00:01:01.246 --> 00:01:02.456 A:middle
Great. Wonderful.

23
00:01:02.456 --> 00:01:04.245 A:middle
So, this is going to be fun.

24
00:01:04.245 --> 00:01:04.965 A:middle
Let's get started.

25
00:01:06.206 --> 00:01:07.766 A:middle
When I talk about
game controllers,

26
00:01:08.236 --> 00:01:11.496 A:middle
what Apple is delivering
is in two parts.

27
00:01:12.646 --> 00:01:15.836 A:middle
The first part is the
MFi Specification.

28
00:01:16.556 --> 00:01:19.086 A:middle
Now, this is for third-party
controller developers.

29
00:01:19.606 --> 00:01:22.866 A:middle
It defines all the hardware
requirements of the controllers.

30
00:01:23.336 --> 00:01:26.076 A:middle
Things like: the control
layouts on the gamepad itself;

31
00:01:26.666 --> 00:01:28.546 A:middle
how the buttons feel
when you press them;

32
00:01:29.836 --> 00:01:32.116 A:middle
and the communication
protocols between the device.

33
00:01:32.706 --> 00:01:36.926 A:middle
And the goal with this
program is to give confidence

34
00:01:36.926 --> 00:01:40.096 A:middle
to consumers that when they
purchase a game controller

35
00:01:40.316 --> 00:01:44.516 A:middle
that has one of these icons
on the box, they're assured

36
00:01:44.516 --> 00:01:47.576 A:middle
that their game controller
is going to work

37
00:01:47.576 --> 00:01:50.606 A:middle
with all your games that support
the game controller framework.

38
00:01:51.306 --> 00:01:54.166 A:middle
So that's the first part,
the MFi Specification.

39
00:01:55.616 --> 00:01:58.706 A:middle
The second part is the
game controller framework.

40
00:01:59.386 --> 00:02:01.036 A:middle
This is the software
side of things,

41
00:02:01.446 --> 00:02:03.706 A:middle
what you as game
developers will be using

42
00:02:03.906 --> 00:02:05.996 A:middle
to integrate game
controllers into your games.

43
00:02:07.246 --> 00:02:10.645 A:middle
This is an iOS and OS X
cross-platform framework.

44
00:02:11.196 --> 00:02:13.196 A:middle
So code that you write
for game controllers

45
00:02:13.196 --> 00:02:15.236 A:middle
in one is directly
usable in the other.

46
00:02:15.366 --> 00:02:19.256 A:middle
And it features a simple
API, which allows you

47
00:02:19.256 --> 00:02:22.896 A:middle
to find controllers and read the
input off of those controllers.

48
00:02:23.746 --> 00:02:29.126 A:middle
And the goal with this side of
things with the framework is

49
00:02:29.126 --> 00:02:32.506 A:middle
to give you one API
so that you can focus

50
00:02:32.506 --> 00:02:33.666 A:middle
on developing your game,

51
00:02:34.196 --> 00:02:37.276 A:middle
integrating game controllers
really smoothly and not have

52
00:02:37.336 --> 00:02:39.986 A:middle
to worry about little
variations in all sorts

53
00:02:39.986 --> 00:02:41.186 A:middle
of different controllers.

54
00:02:41.766 --> 00:02:45.616 A:middle
So that's the second part,
the game controller framework.

55
00:02:46.526 --> 00:02:48.696 A:middle
Now, what kind of
controllers are available?

56
00:02:50.026 --> 00:02:51.006 A:middle
There are three types.

57
00:02:51.596 --> 00:02:54.526 A:middle
The first type is a form-fitting
standard controller.

58
00:02:55.406 --> 00:02:57.426 A:middle
And by form-fitting, we mean

59
00:02:57.426 --> 00:02:59.766 A:middle
that the controller
encases the device.

60
00:03:01.436 --> 00:03:05.246 A:middle
Therefore, the touch screen is
easily accessible while they're

61
00:03:05.246 --> 00:03:06.226 A:middle
playing with the game pad,

62
00:03:06.366 --> 00:03:08.846 A:middle
and so is motion
control of the device.

63
00:03:09.926 --> 00:03:13.256 A:middle
And by "standard," we're
referring to the controls layout

64
00:03:13.336 --> 00:03:17.066 A:middle
on the gamepad, specifically
that there's a D-pad,

65
00:03:17.146 --> 00:03:21.726 A:middle
that there are four face
buttons (A, B, X and Y,

66
00:03:21.726 --> 00:03:24.016 A:middle
always in these colors
and in these locations)

67
00:03:24.816 --> 00:03:27.916 A:middle
and two shoulder
buttons (L and R).

68
00:03:28.426 --> 00:03:29.816 A:middle
So that's the first
controller type.

69
00:03:30.576 --> 00:03:34.066 A:middle
The second controller
is the form-fitting

70
00:03:34.066 --> 00:03:35.136 A:middle
extended controller.

71
00:03:35.596 --> 00:03:37.056 A:middle
So it too is form-fitting.

72
00:03:38.086 --> 00:03:41.636 A:middle
And the extended control layout
has all the same controls

73
00:03:41.966 --> 00:03:43.136 A:middle
of the standard controller,

74
00:03:43.906 --> 00:03:49.086 A:middle
but it adds to it two
thumbsticks and two triggers.

75
00:03:49.586 --> 00:03:52.636 A:middle
That's the second
controller type.

76
00:03:53.536 --> 00:03:57.816 A:middle
The third controller type is the
standalone extended controller.

77
00:03:58.466 --> 00:04:03.496 A:middle
And by standalone, we mean
the controller does not encase

78
00:04:03.546 --> 00:04:04.166 A:middle
the device.

79
00:04:05.176 --> 00:04:07.766 A:middle
So the touch screen is
not easily accessible.

80
00:04:08.156 --> 00:04:09.986 A:middle
Motion control is not an option.

81
00:04:10.646 --> 00:04:13.276 A:middle
You're only getting input
from the controller itself.

82
00:04:14.386 --> 00:04:17.146 A:middle
And again, this has the exact
same extended control layout

83
00:04:17.146 --> 00:04:18.505 A:middle
as the previous extended
controller.

84
00:04:19.185 --> 00:04:22.506 A:middle
So that's an overview.

85
00:04:23.366 --> 00:04:26.096 A:middle
Now, I'm going to focus
the rest of my talk

86
00:04:26.136 --> 00:04:28.896 A:middle
on the game controller
framework itself

87
00:04:28.946 --> 00:04:30.946 A:middle
and how you use the framework

88
00:04:31.266 --> 00:04:32.956 A:middle
to integrate game
controllers into your games.

89
00:04:33.476 --> 00:04:36.796 A:middle
Specifically, we're going to
find out inside your game,

90
00:04:36.896 --> 00:04:37.586 A:middle
how do you know

91
00:04:37.876 --> 00:04:40.216 A:middle
which controllers are
available for your game to use?

92
00:04:40.756 --> 00:04:42.156 A:middle
We're going to talk about
finding controllers.

93
00:04:43.036 --> 00:04:45.466 A:middle
I'm also going to talk about
the various inputs found

94
00:04:45.466 --> 00:04:49.246 A:middle
on controllers, like the buttons
and the D-pads and how those map

95
00:04:49.356 --> 00:04:51.846 A:middle
in software, and how
you can read whether

96
00:04:51.846 --> 00:04:54.056 A:middle
or not a player is pressing
the A button or the D-pad.

97
00:04:55.346 --> 00:04:57.606 A:middle
I'm also going to
talk about what's new.

98
00:04:58.166 --> 00:04:59.576 A:middle
What have we been
working on this past year?

99
00:04:59.576 --> 00:05:01.226 A:middle
What are we introducing at iOS 8

100
00:05:01.226 --> 00:05:02.686 A:middle
and with respect to
game controllers?

101
00:05:03.436 --> 00:05:05.376 A:middle
One really cool thing that
I'm excited to tell you

102
00:05:05.376 --> 00:05:08.246 A:middle
about is controller forwarding.

103
00:05:09.166 --> 00:05:14.096 A:middle
In a nutshell, this is
a way for a controller

104
00:05:14.096 --> 00:05:17.696 A:middle
with a snapped-in iPhone to be
used as a wireless controller

105
00:05:17.696 --> 00:05:19.546 A:middle
to control the game
play experience

106
00:05:19.606 --> 00:05:23.746 A:middle
on another device, like an iPad.

107
00:05:23.926 --> 00:05:25.356 A:middle
And throughout the talk,

108
00:05:25.406 --> 00:05:30.796 A:middle
I'm going to be giving a heavy
emphasis to design guidance.

109
00:05:31.346 --> 00:05:33.106 A:middle
It's actually fairly
straightforward

110
00:05:33.106 --> 00:05:35.376 A:middle
to integrate game
controllers into your game.

111
00:05:36.256 --> 00:05:38.996 A:middle
And it's going to be
really instructive to talk

112
00:05:38.996 --> 00:05:41.186 A:middle
about design guidance
based on things

113
00:05:41.186 --> 00:05:43.436 A:middle
that we've seen this past year.

114
00:05:44.046 --> 00:05:47.716 A:middle
And I'd really like
to focus especially

115
00:05:48.006 --> 00:05:51.466 A:middle
on an Apple Design Award winning
game this year, Leo's Fortune,

116
00:05:52.326 --> 00:05:55.566 A:middle
because it integrates game
controllers really, really well.

117
00:05:55.726 --> 00:05:56.946 A:middle
It's a fantastic integration.

118
00:05:56.946 --> 00:05:57.686 A:middle
And I think it's going

119
00:05:57.686 --> 00:06:02.226 A:middle
to be really instructive
for all of us.

120
00:06:02.486 --> 00:06:04.946 A:middle
So, let's talk about
finding controllers.

121
00:06:05.066 --> 00:06:08.116 A:middle
How do I know which controllers
are available to my game?

122
00:06:08.756 --> 00:06:13.106 A:middle
The first thing you're going
to want know is the main class

123
00:06:13.156 --> 00:06:14.276 A:middle
that you're going
to be interacting

124
00:06:14.276 --> 00:06:16.316 A:middle
with in the game
controller framework is

125
00:06:16.316 --> 00:06:17.486 A:middle
called GCController.

126
00:06:17.486 --> 00:06:20.946 A:middle
Now, this is the same class
for all controller types.

127
00:06:21.826 --> 00:06:24.116 A:middle
And it allows you to do a
few things, like finding

128
00:06:24.116 --> 00:06:27.016 A:middle
which controllers are available,
reading the inputs off

129
00:06:27.016 --> 00:06:30.106 A:middle
of the controllers and
additional information

130
00:06:30.106 --> 00:06:32.416 A:middle
about the controller
itself, such as whether

131
00:06:32.416 --> 00:06:35.406 A:middle
or not it's form-fitting, if
it's standard or extended.

132
00:06:36.126 --> 00:06:40.706 A:middle
Now, to find which controllers
are currently connected,

133
00:06:41.616 --> 00:06:44.766 A:middle
call the controllers class
method on GCController.

134
00:06:45.296 --> 00:06:48.026 A:middle
It returns you an array of
currently connected controllers.

135
00:06:48.666 --> 00:06:51.926 A:middle
Or, an empty array if no
controllers are connected.

136
00:06:53.356 --> 00:06:55.066 A:middle
Now, this array starts
off empty.

137
00:06:55.646 --> 00:06:58.036 A:middle
And it's updated as
controllers are added

138
00:06:58.036 --> 00:06:59.256 A:middle
and removed from the system.

139
00:06:59.796 --> 00:07:01.286 A:middle
So whenever you check
this method,

140
00:07:02.206 --> 00:07:03.856 A:middle
it'll return you the
latest information

141
00:07:03.856 --> 00:07:05.066 A:middle
on what's currently connected.

142
00:07:05.286 --> 00:07:09.736 A:middle
Now let me explain
visually how we're going

143
00:07:09.736 --> 00:07:10.816 A:middle
to structure our code.

144
00:07:11.856 --> 00:07:15.216 A:middle
There are two methods that we're
particularly interested in.

145
00:07:15.686 --> 00:07:18.236 A:middle
"One is application:
didFinishLaunching WithOptions".

146
00:07:18.876 --> 00:07:21.626 A:middle
And the second is a method
you're expected to create.

147
00:07:22.296 --> 00:07:24.406 A:middle
In this case we're calling
it setupControllers.

148
00:07:25.416 --> 00:07:28.696 A:middle
Now setupControllers
is your central method

149
00:07:28.736 --> 00:07:33.076 A:middle
where you track controller
state and take action

150
00:07:33.076 --> 00:07:34.706 A:middle
as appropriate to your game.

151
00:07:35.376 --> 00:07:36.976 A:middle
In there we're going to
check the controllers array.

152
00:07:38.626 --> 00:07:42.946 A:middle
Next, we're going to connect
and disconnect controllers.

153
00:07:42.946 --> 00:07:44.846 A:middle
And we want to find
out specifically

154
00:07:44.846 --> 00:07:46.126 A:middle
when they connect
and disconnect.

155
00:07:46.156 --> 00:07:47.846 A:middle
So we're going to
set up notifications

156
00:07:48.146 --> 00:07:49.976 A:middle
to be notified when
players do this.

157
00:07:51.096 --> 00:07:53.706 A:middle
And importantly,
we're going to --

158
00:07:53.946 --> 00:07:56.176 A:middle
the action we're going to take
whenever a controller connects

159
00:07:56.176 --> 00:07:59.406 A:middle
or disconnects is to call
our setupControllers method.

160
00:08:00.346 --> 00:08:02.656 A:middle
Lastly, we're going to setup --

161
00:08:02.656 --> 00:08:05.206 A:middle
we're going to kick off a
wireless discovery process.

162
00:08:05.696 --> 00:08:08.896 A:middle
And what this does is it
allows those controllers

163
00:08:09.016 --> 00:08:11.496 A:middle
which communicate
wirelessly to pair

164
00:08:11.496 --> 00:08:14.736 A:middle
with your phone right
within your game.

165
00:08:15.086 --> 00:08:16.866 A:middle
So you don't have to exit to --

166
00:08:16.986 --> 00:08:18.666 A:middle
or your players don't
have to exit

167
00:08:18.666 --> 00:08:21.126 A:middle
to the settings screen
in order to do that.

168
00:08:21.886 --> 00:08:23.996 A:middle
And importantly, notice
the cascade effect here.

169
00:08:24.316 --> 00:08:26.116 A:middle
When we kickoff wireless
discovery,

170
00:08:26.596 --> 00:08:28.556 A:middle
whenever controllers
happen to be discovered,

171
00:08:29.616 --> 00:08:31.926 A:middle
connection notifications
are posted,

172
00:08:32.296 --> 00:08:33.686 A:middle
which in turn will cascade down

173
00:08:33.686 --> 00:08:35.155 A:middle
and call our setupControllers
method.

174
00:08:35.655 --> 00:08:36.666 A:middle
So that's the game plan.

175
00:08:36.666 --> 00:08:38.765 A:middle
Let's look at the code
for how to do that.

176
00:08:40.006 --> 00:08:42.596 A:middle
We're within application:
didFinishLaunching WithOptions.

177
00:08:43.006 --> 00:08:46.256 A:middle
And you'll notice the first
thing we do is we call --

178
00:08:46.396 --> 00:08:49.746 A:middle
or we check whether the
GCController class exists.

179
00:08:50.416 --> 00:08:52.686 A:middle
And by extension, what we're
doing here is we're checking

180
00:08:52.686 --> 00:08:55.906 A:middle
whether the game controller
framework exists in the version

181
00:08:55.906 --> 00:08:58.056 A:middle
of the operating system that
your game is running on.

182
00:08:58.936 --> 00:09:00.066 A:middle
This is important for those

183
00:09:00.066 --> 00:09:04.926 A:middle
of you whose games support
operating systems earlier

184
00:09:04.926 --> 00:09:08.336 A:middle
than iOS 7 and earlier
than OS X Mavericks.

185
00:09:08.946 --> 00:09:11.466 A:middle
(The operating systems where
the game controller framework

186
00:09:11.466 --> 00:09:12.146 A:middle
was introduced.)

187
00:09:13.846 --> 00:09:16.196 A:middle
Assuming the game
controller framework exists,

188
00:09:16.806 --> 00:09:18.616 A:middle
then we go ahead and register

189
00:09:18.616 --> 00:09:21.276 A:middle
for notifications whenever
controllers connect

190
00:09:21.276 --> 00:09:21.896 A:middle
and disconnect.

191
00:09:22.886 --> 00:09:24.646 A:middle
We do this using the
notification names

192
00:09:24.936 --> 00:09:27.446 A:middle
GCControllerDid
ConnectNotification

193
00:09:27.906 --> 00:09:30.376 A:middle
and GCControllerDid
DisconnectNotification.

194
00:09:30.926 --> 00:09:34.026 A:middle
And you'll notice that in
both of these situations,

195
00:09:34.236 --> 00:09:36.116 A:middle
whenever these notifications
are posted,

196
00:09:36.816 --> 00:09:38.376 A:middle
we're calling setupControllers.

197
00:09:40.856 --> 00:09:44.656 A:middle
Lastly, we call
startWirelessController

198
00:09:44.656 --> 00:09:46.386 A:middle
Discovery WithCompletionHandler.

199
00:09:47.026 --> 00:09:50.306 A:middle
Now, this kicks off
asynchronous scanning

200
00:09:50.686 --> 00:09:52.246 A:middle
of wireless controllers.

201
00:09:52.826 --> 00:09:58.166 A:middle
When the completion handler
is called, the scanning

202
00:09:58.166 --> 00:10:00.066 A:middle
of wireless controllers
has stopped.

203
00:10:00.746 --> 00:10:04.086 A:middle
And any controllers
that are wireless

204
00:10:04.086 --> 00:10:07.156 A:middle
that have already been
discovered will have already

205
00:10:07.156 --> 00:10:10.206 A:middle
called, or rather, posted
notifications for connection.

206
00:10:10.716 --> 00:10:11.946 A:middle
And by association,

207
00:10:11.946 --> 00:10:14.186 A:middle
setupControllers will
have already been called.

208
00:10:15.386 --> 00:10:18.826 A:middle
So the important takeaway here
is it's completely unnecessary

209
00:10:18.826 --> 00:10:21.076 A:middle
to explicitly call
setupControllers

210
00:10:21.156 --> 00:10:21.936 A:middle
within the handler.

211
00:10:21.936 --> 00:10:26.286 A:middle
Now let's look at our other
method, setupControllers.

212
00:10:27.616 --> 00:10:29.286 A:middle
Here we're checking
the controllers array.

213
00:10:30.386 --> 00:10:33.406 A:middle
And if it's non-empty, we take
action appropriate to our game.

214
00:10:34.046 --> 00:10:35.856 A:middle
So that's it.

215
00:10:35.856 --> 00:10:36.656 A:middle
That's how you find

216
00:10:36.656 --> 00:10:38.606 A:middle
which controllers are
available on your system.

217
00:10:39.596 --> 00:10:42.516 A:middle
Now, I'd like to offer
some design guidance on how

218
00:10:42.516 --> 00:10:45.096 A:middle
to gracefully handle
connections and disconnections.

219
00:10:45.936 --> 00:10:47.946 A:middle
When a player connects
a controller,

220
00:10:49.336 --> 00:10:52.476 A:middle
they're communicating intent
to use that controller

221
00:10:52.476 --> 00:10:54.406 A:middle
as their preferred control
scheme for your game.

222
00:10:55.696 --> 00:10:57.936 A:middle
And your game should
react accordingly.

223
00:10:58.436 --> 00:11:01.606 A:middle
So, specifically, move to
controller-based input.

224
00:11:02.806 --> 00:11:06.156 A:middle
Remove any on-screen
visuals that are virtual,

225
00:11:06.156 --> 00:11:09.746 A:middle
like virtual D-pads and analog
sticks, virtual buttons.

226
00:11:10.296 --> 00:11:13.916 A:middle
Those are now redundant since
the gamepad already has those.

227
00:11:15.336 --> 00:11:17.296 A:middle
Each gamepad also
has a pause button.

228
00:11:17.296 --> 00:11:19.076 A:middle
So even the little
pause button overlay

229
00:11:19.076 --> 00:11:22.246 A:middle
on the screen can be
offloaded from the screen

230
00:11:22.686 --> 00:11:25.166 A:middle
because the game
controller has that.

231
00:11:25.356 --> 00:11:27.906 A:middle
And lastly, you're going to
want to set the playerIndex,

232
00:11:28.306 --> 00:11:29.766 A:middle
which is a property
on the controller.

233
00:11:30.176 --> 00:11:32.496 A:middle
And this will light up the
LEDs on the controller.

234
00:11:32.966 --> 00:11:34.686 A:middle
This gives important
feedback to your player

235
00:11:34.936 --> 00:11:37.196 A:middle
that this game controller
is recognized

236
00:11:37.196 --> 00:11:38.416 A:middle
and being used by your game.

237
00:11:38.946 --> 00:11:42.466 A:middle
And disconnections can happen
for a variety of reasons.

238
00:11:42.466 --> 00:11:44.926 A:middle
Either the player explicitly
disconnects the controller,

239
00:11:45.166 --> 00:11:48.586 A:middle
or maybe for whatever reason,
the connection becomes loose

240
00:11:48.586 --> 00:11:50.546 A:middle
or the batteries run out.

241
00:11:50.546 --> 00:11:53.796 A:middle
In this case, as a
convenience to the players,

242
00:11:53.836 --> 00:11:55.066 A:middle
consider pausing the game play

243
00:11:55.066 --> 00:11:56.406 A:middle
if that's appropriate
for your game.

244
00:11:57.036 --> 00:11:59.506 A:middle
Give them an opportunity
to reconnect or return

245
00:11:59.506 --> 00:12:01.846 A:middle
to regular controls if
that's an appropriate action.

246
00:12:02.676 --> 00:12:06.686 A:middle
Now, I'd like to focus
in on the player's intent

247
00:12:06.686 --> 00:12:07.436 A:middle
when they connect.

248
00:12:09.276 --> 00:12:11.946 A:middle
Some games that use
tilt-and-touch control,

249
00:12:13.336 --> 00:12:15.676 A:middle
upon entering gameplay,
they present the player

250
00:12:15.676 --> 00:12:17.886 A:middle
with this kind of an
option: "Do you want

251
00:12:17.886 --> 00:12:19.596 A:middle
to use tilt control
or touch control?"

252
00:12:20.226 --> 00:12:24.646 A:middle
And this is a great option for
games to present to players.

253
00:12:26.356 --> 00:12:28.766 A:middle
Until they snap in
a game controller.

254
00:12:30.006 --> 00:12:32.586 A:middle
Now, the player's intent is
to use the game controller.

255
00:12:33.056 --> 00:12:35.956 A:middle
And this kind of a choice
is actually confusing

256
00:12:35.956 --> 00:12:36.626 A:middle
to the players.

257
00:12:37.086 --> 00:12:37.926 A:middle
Does this actually mean

258
00:12:37.926 --> 00:12:39.876 A:middle
that this game doesn't
support game controllers?

259
00:12:40.956 --> 00:12:43.296 A:middle
Or does it mean that my
controller isn't connected

260
00:12:43.296 --> 00:12:44.476 A:middle
properly to my phone?

261
00:12:45.556 --> 00:12:47.016 A:middle
Or if I select one
of these options,

262
00:12:47.016 --> 00:12:49.526 A:middle
will that disable
game controller input?

263
00:12:50.876 --> 00:12:53.326 A:middle
Instead, if you have a
dialog that looks like this

264
00:12:53.326 --> 00:12:55.906 A:middle
in your game, gate it on whether

265
00:12:55.906 --> 00:12:57.686 A:middle
or not a controller is
currently connected.

266
00:12:58.136 --> 00:13:01.366 A:middle
If it is, that is sufficient
intent that the player wishes

267
00:13:01.366 --> 00:13:02.476 A:middle
to use game controllers.

268
00:13:02.476 --> 00:13:04.126 A:middle
And this kind of a
dialog is unnecessary.

269
00:13:05.946 --> 00:13:09.466 A:middle
Now, another kind of dialog
you might be tempted to put

270
00:13:09.466 --> 00:13:12.266 A:middle
up is one like this:
"Game controller detected.

271
00:13:12.546 --> 00:13:13.366 A:middle
Would you like to use it?

272
00:13:13.366 --> 00:13:13.966 A:middle
Yes or No."

273
00:13:13.966 --> 00:13:16.496 A:middle
And at least we're giving
feedback to the player that,

274
00:13:16.496 --> 00:13:18.926 A:middle
yes, this controller is
connected and recognized.

275
00:13:19.376 --> 00:13:22.906 A:middle
But again, the intent
that the player has

276
00:13:22.906 --> 00:13:24.326 A:middle
when they connect
the controller is

277
00:13:24.326 --> 00:13:25.536 A:middle
that they actually
want to use it.

278
00:13:25.746 --> 00:13:27.856 A:middle
And so such a dialog
is redundant.

279
00:13:28.256 --> 00:13:29.496 A:middle
If you have this
kind of a dialog,

280
00:13:29.706 --> 00:13:31.746 A:middle
you don't actually need it.

281
00:13:31.836 --> 00:13:33.616 A:middle
Just use the controller
if it's available.

282
00:13:34.796 --> 00:13:37.166 A:middle
And as an example of a game
that does this really well,

283
00:13:37.166 --> 00:13:38.856 A:middle
I'd like to look
at Leo's Fortune.

284
00:13:39.436 --> 00:13:41.486 A:middle
Here it is in one of
its touchscreen modes

285
00:13:41.876 --> 00:13:44.536 A:middle
where you're controlling the
main character using virtual

286
00:13:44.536 --> 00:13:45.936 A:middle
buttons along the
bottom of the screen.

287
00:13:46.586 --> 00:13:47.226 A:middle
This is great.

288
00:13:47.316 --> 00:13:48.916 A:middle
We don't have a game
controller attached.

289
00:13:49.636 --> 00:13:51.636 A:middle
And the game is very
obviously presenting these

290
00:13:51.636 --> 00:13:52.436 A:middle
control options.

291
00:13:53.026 --> 00:13:55.086 A:middle
Now watch what happens when
we connect a controller.

292
00:13:57.436 --> 00:13:59.266 A:middle
The virtual buttons went away.

293
00:13:59.346 --> 00:14:03.536 A:middle
And importantly, the player
didn't have to take any action.

294
00:14:05.086 --> 00:14:06.366 A:middle
No dialogs were presented.

295
00:14:06.516 --> 00:14:07.716 A:middle
No choice was given.

296
00:14:08.176 --> 00:14:10.746 A:middle
The game just assumes
that the existence

297
00:14:10.956 --> 00:14:15.626 A:middle
of a connected controller is
intent and permission to use it.

298
00:14:19.666 --> 00:14:21.776 A:middle
So, we've talked about
finding controllers.

299
00:14:22.096 --> 00:14:24.926 A:middle
The next step is how do I
actually read the inputs?

300
00:14:25.716 --> 00:14:27.866 A:middle
How do I find out if the
A button is being pressed?

301
00:14:28.206 --> 00:14:31.216 A:middle
And before I get to that,
let's go through and talk

302
00:14:31.216 --> 00:14:33.716 A:middle
about what kind of inputs
you're going to find

303
00:14:33.716 --> 00:14:34.936 A:middle
on the controllers themselves.

304
00:14:38.256 --> 00:14:40.946 A:middle
So, first and foremost,
when you're designing

305
00:14:40.946 --> 00:14:45.106 A:middle
for game controllers, keep in
mind to first design for touch.

306
00:14:45.596 --> 00:14:48.706 A:middle
You want the native controls
of your operating system

307
00:14:49.076 --> 00:14:50.446 A:middle
to be usable at all times.

308
00:14:50.786 --> 00:14:51.806 A:middle
And this makes sense.

309
00:14:52.426 --> 00:14:55.066 A:middle
If a game player downloads
your game from the App Store,

310
00:14:56.126 --> 00:14:58.686 A:middle
they're going to have the
expectation -- correctly so --

311
00:14:58.686 --> 00:15:00.916 A:middle
that they're able to play
it regardless of whether

312
00:15:00.916 --> 00:15:02.216 A:middle
or not they have
a game controller.

313
00:15:03.196 --> 00:15:04.496 A:middle
So, put another way,

314
00:15:04.746 --> 00:15:08.166 A:middle
game controllers cannot be
required to play your game.

315
00:15:08.166 --> 00:15:11.886 A:middle
Now, let's talk about profiles.

316
00:15:12.176 --> 00:15:16.166 A:middle
So profiles are the software
mapping to the hardware.

317
00:15:16.926 --> 00:15:18.826 A:middle
So we have three
different controller types.

318
00:15:19.516 --> 00:15:22.476 A:middle
And they are mapped in software
to two different profiles.

319
00:15:23.686 --> 00:15:26.126 A:middle
One is called gamepad,
and the second is

320
00:15:26.126 --> 00:15:28.026 A:middle
called extendedGamepad.

321
00:15:28.366 --> 00:15:31.576 A:middle
And you'll notice all
controllers support the

322
00:15:31.576 --> 00:15:32.706 A:middle
gamepad profile.

323
00:15:32.706 --> 00:15:37.206 A:middle
Now, the physical controllers,

324
00:15:37.206 --> 00:15:39.706 A:middle
which are extended
control layouts,

325
00:15:40.056 --> 00:15:42.436 A:middle
also support the
extendedGamepad.

326
00:15:43.456 --> 00:15:47.996 A:middle
So if you support only
the gamepad profile,

327
00:15:47.996 --> 00:15:49.936 A:middle
you're guaranteed that
your game will be playable

328
00:15:49.936 --> 00:15:51.246 A:middle
on any controller available.

329
00:15:51.536 --> 00:15:54.826 A:middle
And if you wish to support
the analog thumbsticks

330
00:15:54.826 --> 00:15:58.376 A:middle
and the triggers, then you'll
target the extendedGamepad

331
00:15:58.376 --> 00:15:59.186 A:middle
profile as well.

332
00:16:00.106 --> 00:16:02.116 A:middle
So these are properties on
the controller instance.

333
00:16:02.376 --> 00:16:06.556 A:middle
Let's look at what properties
are within the gamepad profile.

334
00:16:06.686 --> 00:16:12.856 A:middle
We have buttonA, buttonB,
buttonX, and buttonY.

335
00:16:12.856 --> 00:16:14.946 A:middle
And these correspond to
the four face buttons.

336
00:16:16.006 --> 00:16:18.906 A:middle
Similarly, the two shoulder
buttons are called leftShoulder

337
00:16:18.906 --> 00:16:20.316 A:middle
and rightShoulder
in the framework.

338
00:16:20.316 --> 00:16:24.066 A:middle
And the D-pad is
simply called dpad.

339
00:16:24.226 --> 00:16:27.046 A:middle
Now, switching over to
the extended profile,

340
00:16:27.706 --> 00:16:32.576 A:middle
extendedGamepad, it has all the
same properties from gamepad

341
00:16:32.616 --> 00:16:36.336 A:middle
and in addition, we
add leftThumbstick

342
00:16:36.336 --> 00:16:41.826 A:middle
and rightThumbstick, and
leftTrigger and rightTrigger,

343
00:16:42.516 --> 00:16:44.126 A:middle
corresponding to the
additional controls

344
00:16:44.166 --> 00:16:45.626 A:middle
that extended gamepads give us.

345
00:16:46.066 --> 00:16:48.856 A:middle
Now I'd like to call your
attention to the fact

346
00:16:48.856 --> 00:16:52.826 A:middle
that triggers and face buttons,
while physically different

347
00:16:53.456 --> 00:16:54.826 A:middle
to the Game Controller
framework,

348
00:16:54.826 --> 00:16:58.236 A:middle
we use the same data type:
GCControllerButtonInput.

349
00:16:59.626 --> 00:17:02.316 A:middle
Similarly, D-pads
and thumbsticks,

350
00:17:02.726 --> 00:17:05.606 A:middle
while being physically,
different share the same class,

351
00:17:05.876 --> 00:17:07.516 A:middle
called GCControllerDirectionPad.

352
00:17:08.286 --> 00:17:13.826 A:middle
So let's talk about those
classes, buttons and D-pads.

353
00:17:14.016 --> 00:17:17.215 A:middle
GCControllerButtonInput
represents all the buttons

354
00:17:17.425 --> 00:17:18.586 A:middle
available on the controller.

355
00:17:19.165 --> 00:17:20.915 A:middle
And these can be
read in two ways.

356
00:17:21.496 --> 00:17:23.776 A:middle
One is with the pressed
property.

357
00:17:23.866 --> 00:17:27.175 A:middle
And this returns the
classic, digital version

358
00:17:27.226 --> 00:17:29.996 A:middle
of a button whether or not
it's being pressed: Yes or No.

359
00:17:31.396 --> 00:17:34.506 A:middle
But, all buttons on game
controllers are also

360
00:17:34.506 --> 00:17:35.376 A:middle
pressure sensitive.

361
00:17:35.956 --> 00:17:38.176 A:middle
And if this something
that's useful for your game,

362
00:17:38.696 --> 00:17:40.616 A:middle
you read that using
the value property.

363
00:17:41.416 --> 00:17:44.886 A:middle
This returns you a float
normalized between 0

364
00:17:44.886 --> 00:17:47.926 A:middle
and 1 indicating how hard
the button is being pressed.

365
00:17:48.406 --> 00:17:56.116 A:middle
Now, the A and B buttons have a
special convention in iOS games

366
00:17:56.116 --> 00:17:57.176 A:middle
and GameController games.

367
00:17:58.206 --> 00:18:00.986 A:middle
The A button is intended
to be your primary action.

368
00:18:01.706 --> 00:18:05.166 A:middle
And the B button is to be
used as the secondary action.

369
00:18:05.976 --> 00:18:07.826 A:middle
And so you need to think
about, with your game:

370
00:18:07.986 --> 00:18:09.416 A:middle
"What is my primary action?

371
00:18:09.876 --> 00:18:10.796 A:middle
Is it jumping?

372
00:18:11.236 --> 00:18:12.306 A:middle
Is it shooting?

373
00:18:12.866 --> 00:18:14.716 A:middle
Is it throwing a ball?"

374
00:18:15.836 --> 00:18:17.936 A:middle
And also, think about
it in the context of UI.

375
00:18:18.656 --> 00:18:21.406 A:middle
If you're not in actual game
play, what are the primary

376
00:18:21.406 --> 00:18:22.516 A:middle
and secondary actions?

377
00:18:23.766 --> 00:18:27.126 A:middle
For UI, it should be
to confirm and accept

378
00:18:27.476 --> 00:18:28.676 A:middle
for the primary action.

379
00:18:29.836 --> 00:18:31.186 A:middle
And the B button should be used

380
00:18:31.636 --> 00:18:33.836 A:middle
as cancelling, the
secondary action.

381
00:18:37.836 --> 00:18:41.146 A:middle
Let's talk about
GCControllerDirectionPad now.

382
00:18:41.786 --> 00:18:44.396 A:middle
Again, this is used for
both D-pads and thumbsticks.

383
00:18:45.026 --> 00:18:47.376 A:middle
And it's treated in
two different ways.

384
00:18:47.756 --> 00:18:51.776 A:middle
One is that it's treated
as four buttons named Up,

385
00:18:51.776 --> 00:18:53.026 A:middle
Down, Left and Right.

386
00:18:53.026 --> 00:18:58.776 A:middle
And the second way we treat it
is as two axes, xAxis and yAxis.

387
00:18:59.946 --> 00:19:02.076 A:middle
And you'll recall that
I said each button

388
00:19:02.076 --> 00:19:04.606 A:middle
on the control pad is
pressure sensitive?

389
00:19:04.736 --> 00:19:06.996 A:middle
Well, that's also true of
Up, Down, Left and Right,

390
00:19:06.996 --> 00:19:08.106 A:middle
since they're the same class.

391
00:19:09.206 --> 00:19:11.586 A:middle
So D-pads are effectively
pressure sensitive

392
00:19:11.686 --> 00:19:12.946 A:middle
and digital as well.

393
00:19:14.126 --> 00:19:15.946 A:middle
Let's look at the axis.

394
00:19:16.236 --> 00:19:19.656 A:middle
Now axes -- the value that's
returned from an axis --

395
00:19:19.946 --> 00:19:22.836 A:middle
is normalized between
negative 1 and positive 1.

396
00:19:22.996 --> 00:19:28.766 A:middle
And a value of 0 you can rely
on being the axis at rest,

397
00:19:29.446 --> 00:19:31.586 A:middle
meaning the player is
not pressing that axis.

398
00:19:32.846 --> 00:19:34.746 A:middle
Now, you have a guaranteed
minimum range

399
00:19:34.746 --> 00:19:35.656 A:middle
of the unit circle.

400
00:19:36.276 --> 00:19:37.856 A:middle
Maximum range of
the unit square.

401
00:19:38.726 --> 00:19:41.066 A:middle
And for those of you who may
have dealt with calibration

402
00:19:41.066 --> 00:19:45.226 A:middle
of joysticks and deadzoning
before, do not do that yourself.

403
00:19:45.226 --> 00:19:48.876 A:middle
We already take care
of that for you.

404
00:19:49.426 --> 00:19:50.656 A:middle
So that's all the controls.

405
00:19:50.656 --> 00:19:52.236 A:middle
And now you can get
on with the business

406
00:19:52.236 --> 00:19:55.646 A:middle
of assigning game actions
to controller inputs.

407
00:19:56.406 --> 00:20:00.646 A:middle
And one piece of advice I can
offer is a principle which a lot

408
00:20:00.646 --> 00:20:02.106 A:middle
of games use to great effect,

409
00:20:02.236 --> 00:20:04.986 A:middle
which is to group
logically similar actions.

410
00:20:05.616 --> 00:20:07.386 A:middle
So in Leo's Fortune,
for instance,

411
00:20:07.746 --> 00:20:09.586 A:middle
our main character
has four actions.

412
00:20:09.846 --> 00:20:14.086 A:middle
He can walk left, right and
he can jump and he can stomp.

413
00:20:14.686 --> 00:20:20.416 A:middle
So the developers have
mapped walking left

414
00:20:20.416 --> 00:20:22.946 A:middle
and walking right to the D-pad.

415
00:20:23.616 --> 00:20:26.266 A:middle
Walking left and walking right
are logically similar actions.

416
00:20:26.266 --> 00:20:27.016 A:middle
It's just walking.

417
00:20:28.066 --> 00:20:30.076 A:middle
And so it makes sense to
group those on the D-pad.

418
00:20:31.066 --> 00:20:34.086 A:middle
Also, they're making good
use of the D-pad's ability

419
00:20:34.086 --> 00:20:35.676 A:middle
to readily switch directions.

420
00:20:37.186 --> 00:20:41.106 A:middle
Now, jumping is assigned
to the A button.

421
00:20:42.436 --> 00:20:45.826 A:middle
This is because jumping
is logically dissimilar

422
00:20:45.826 --> 00:20:48.496 A:middle
from horizontal movement,
and so it's separated.

423
00:20:51.316 --> 00:20:53.776 A:middle
They could have assigned
jumping to the Up button,

424
00:20:54.826 --> 00:20:57.036 A:middle
but it's a logically
dissimilar action,

425
00:20:57.036 --> 00:20:59.076 A:middle
so it might have been a little
bit more confusing for players.

426
00:20:59.636 --> 00:21:01.656 A:middle
And, the D-pad's ability

427
00:21:01.656 --> 00:21:04.986 A:middle
to readily switch directions
could actually fight the game

428
00:21:04.986 --> 00:21:09.596 A:middle
player in this case
and result in a lot

429
00:21:09.596 --> 00:21:13.256 A:middle
of inadvertent jumps
instead of lateral movement.

430
00:21:13.826 --> 00:21:16.856 A:middle
Now the last ability
is the stomp ability.

431
00:21:17.066 --> 00:21:18.446 A:middle
That's been assigned
to the B button.

432
00:21:18.556 --> 00:21:20.886 A:middle
So again, logically
dissimilar from walking,

433
00:21:21.116 --> 00:21:22.036 A:middle
so we've separated it.

434
00:21:22.036 --> 00:21:24.406 A:middle
But logically similar
to jumping,

435
00:21:24.686 --> 00:21:27.866 A:middle
so it's nearby to the A button.

436
00:21:28.246 --> 00:21:31.876 A:middle
So now let's actually find
out, now that you know

437
00:21:31.876 --> 00:21:35.226 A:middle
which controls you want
to assign to which actions

438
00:21:35.226 --> 00:21:37.766 A:middle
in your game, let's actually
go ahead and read some input.

439
00:21:38.936 --> 00:21:40.576 A:middle
How do you find out if
the A button is pressed?

440
00:21:40.666 --> 00:21:42.676 A:middle
Well, it's really just as
simple as reading a series

441
00:21:42.676 --> 00:21:45.676 A:middle
of properties:
myController.gamepad --

442
00:21:45.676 --> 00:21:49.706 A:middle
gamepad being the profile
-- .buttonA.pressed.

443
00:21:50.206 --> 00:21:52.316 A:middle
Recall that pressed gives
us the Boolean state

444
00:21:52.316 --> 00:21:53.286 A:middle
for whether the button's
pressed.

445
00:21:53.786 --> 00:21:55.516 A:middle
In this case, we're
going to fire our lasers.

446
00:21:57.096 --> 00:21:58.866 A:middle
Now also in our weapons code,

447
00:21:58.976 --> 00:22:02.656 A:middle
we're going to use
the B button's analog

448
00:22:02.656 --> 00:22:06.056 A:middle
and digital representations for
this portion of the game play.

449
00:22:06.876 --> 00:22:08.996 A:middle
If the B button is
being pressed at (all

450
00:22:08.996 --> 00:22:12.786 A:middle
in the digital sense) then we go
ahead and start firing missiles

451
00:22:12.866 --> 00:22:15.586 A:middle
at a rate that increases
the harder

452
00:22:15.586 --> 00:22:18.386 A:middle
that button is pressed;
B-button .value.

453
00:22:21.096 --> 00:22:23.906 A:middle
Then we apply thrust
to our spaceship based

454
00:22:23.906 --> 00:22:26.436 A:middle
on whether the player is
pressing the D-pad up or down.

455
00:22:27.426 --> 00:22:29.886 A:middle
This is perfect for the
yAxis, so we're going

456
00:22:29.886 --> 00:22:32.066 A:middle
to use the yAxis
representation of the D-pad.

457
00:22:32.646 --> 00:22:37.506 A:middle
And note that we're not guarding
this line of code with a query

458
00:22:37.576 --> 00:22:39.566 A:middle
for whether or not
the axis is pressed.

459
00:22:40.176 --> 00:22:42.236 A:middle
We're leveraging the
fact that we can rely

460
00:22:42.236 --> 00:22:45.386 A:middle
on the yAxis's value being 0

461
00:22:45.386 --> 00:22:46.696 A:middle
when the player's
not pressing it.

462
00:22:47.186 --> 00:22:50.166 A:middle
And our applyThrust
method is resilient to that

463
00:22:50.166 --> 00:22:55.316 A:middle
and does nothing when a
value of 0 is pressed.

464
00:22:55.466 --> 00:22:58.516 A:middle
Lastly, we're taking
special action

465
00:22:58.706 --> 00:23:01.246 A:middle
if the controller that's
controlling our game happens

466
00:23:01.276 --> 00:23:02.656 A:middle
to be an extended controller.

467
00:23:03.466 --> 00:23:05.626 A:middle
You can check if a
controller is extended merely

468
00:23:05.626 --> 00:23:08.896 A:middle
by checking whether or not the
extendedGamepad profile is nil.

469
00:23:10.456 --> 00:23:12.496 A:middle
Notice we weren't doing
that above for gamepad,

470
00:23:12.496 --> 00:23:15.346 A:middle
because gamepad is guaranteed to
be non-nil since it's supported

471
00:23:15.346 --> 00:23:16.556 A:middle
across all controller types.

472
00:23:17.096 --> 00:23:21.626 A:middle
And in this case, we're using
the right thumbstick's position

473
00:23:22.176 --> 00:23:24.926 A:middle
to move a camera in our
game back and forth.

474
00:23:25.656 --> 00:23:27.936 A:middle
Now notice: the weapons
and thrust code,

475
00:23:29.226 --> 00:23:33.116 A:middle
we don't explicitly program for
the extendedGamepad profile.

476
00:23:33.786 --> 00:23:37.236 A:middle
But, the extended
gamepad will fall back

477
00:23:37.236 --> 00:23:39.506 A:middle
and use the same behavior
that's specified here

478
00:23:39.766 --> 00:23:43.896 A:middle
since it's not being
overridden with competing code

479
00:23:43.896 --> 00:23:45.646 A:middle
for the extendedGamepad profile.

480
00:23:46.096 --> 00:23:48.916 A:middle
And what this means for
you is that you don't have

481
00:23:48.916 --> 00:23:52.796 A:middle
to duplicate the same code for
both gamepad and extendedGamepad

482
00:23:52.906 --> 00:23:54.786 A:middle
if you want it to do the
same thing regardless

483
00:23:54.786 --> 00:23:55.606 A:middle
of the type of controller.

484
00:23:56.246 --> 00:24:01.946 A:middle
So that's one way to read
controller inputs, is polling.

485
00:24:02.166 --> 00:24:04.036 A:middle
Doing this once every
game frame, typically.

486
00:24:05.036 --> 00:24:06.536 A:middle
The other way is using events.

487
00:24:06.746 --> 00:24:09.276 A:middle
Sometimes you just want to
be notified when something

488
00:24:09.276 --> 00:24:11.206 A:middle
on your control pad changes.

489
00:24:11.746 --> 00:24:15.846 A:middle
Whether it's a button or
an axis, even collections

490
00:24:16.586 --> 00:24:21.506 A:middle
such as D-pads and thumbsticks,
or profiles if you want to know

491
00:24:21.506 --> 00:24:23.156 A:middle
if anything on the
controller has changed.

492
00:24:23.906 --> 00:24:26.866 A:middle
And you do this by registering
a block as a change handler.

493
00:24:27.516 --> 00:24:29.586 A:middle
Basically, "here's the
code I want you to run

494
00:24:29.886 --> 00:24:31.536 A:middle
when this input changes."

495
00:24:32.796 --> 00:24:34.766 A:middle
So we have valueChangedHandlers.

496
00:24:35.166 --> 00:24:36.856 A:middle
Note "value" corresponds

497
00:24:36.856 --> 00:24:40.506 A:middle
to our querying the
pressure-sensitive nature

498
00:24:40.506 --> 00:24:42.416 A:middle
of the buttons, the
float values.

499
00:24:42.986 --> 00:24:47.796 A:middle
And new for iOS 8, we have
a pressedChangedHandler.

500
00:24:48.646 --> 00:24:50.916 A:middle
This is for querying
digital changes.

501
00:24:52.196 --> 00:24:54.206 A:middle
Let's look at an example of
the pressedChangedHandler.

502
00:24:55.826 --> 00:24:56.706 A:middle
In our game, we want

503
00:24:56.706 --> 00:24:59.626 A:middle
to be notified whenever
the Y button changes state

504
00:25:00.076 --> 00:25:01.126 A:middle
in the digital sense.

505
00:25:02.566 --> 00:25:05.066 A:middle
So we've set up the
pressedChangedHandler.

506
00:25:05.316 --> 00:25:08.996 A:middle
And it's called twice, once
when the button is pressed

507
00:25:08.996 --> 00:25:11.096 A:middle
and another time when
the button is released.

508
00:25:12.026 --> 00:25:15.226 A:middle
And you can filter that based
on the pressed parameter here.

509
00:25:16.076 --> 00:25:17.876 A:middle
In this case, we
actually care about both.

510
00:25:18.016 --> 00:25:21.936 A:middle
So when the button is pressed,
we begin charging a speed boost.

511
00:25:22.576 --> 00:25:26.406 A:middle
And when the button is released,
we actually do the speed boost.

512
00:25:29.306 --> 00:25:31.536 A:middle
Now, use pressure
sensitivity with discernment.

513
00:25:31.586 --> 00:25:34.086 A:middle
There are certain times where
you might be tempted to see

514
00:25:34.086 --> 00:25:36.936 A:middle
if a trigger, for
instance, is being pulled.

515
00:25:37.606 --> 00:25:41.856 A:middle
Don't use the analog "value"
if what you really want to find

516
00:25:41.856 --> 00:25:43.956 A:middle
out is whether or not that
control is being pressed.

517
00:25:44.576 --> 00:25:47.436 A:middle
If so, use "pressed" instead,
the Boolean representation.

518
00:25:48.336 --> 00:25:50.686 A:middle
Also, take advantage of
the pressure-sensitivity

519
00:25:50.686 --> 00:25:54.486 A:middle
of buttons and D-pads.

520
00:25:54.546 --> 00:25:56.366 A:middle
D-pads, while thought
of traditionally

521
00:25:56.366 --> 00:26:00.286 A:middle
as a digital-only
input, are a great way

522
00:26:00.606 --> 00:26:02.266 A:middle
to get 360 degree movement.

523
00:26:02.746 --> 00:26:04.706 A:middle
So this is really
important for players

524
00:26:04.706 --> 00:26:09.476 A:middle
who have a standard gamepad
without analog thumbsticks.

525
00:26:09.636 --> 00:26:11.176 A:middle
The D-pad behaves really nicely.

526
00:26:11.176 --> 00:26:13.716 A:middle
We spent a lot of work
making it work really nicely

527
00:26:13.716 --> 00:26:15.696 A:middle
as an analog supplement.

528
00:26:17.026 --> 00:26:18.096 A:middle
And Face Buttons.

529
00:26:18.876 --> 00:26:20.436 A:middle
You can add nuance to your game

530
00:26:21.046 --> 00:26:22.786 A:middle
by using the pressure
sensitive values.

531
00:26:23.046 --> 00:26:26.176 A:middle
Maybe you have a soccer
game and you gate how hard

532
00:26:26.176 --> 00:26:30.096 A:middle
or soft your passes and your
shots are based on how hard

533
00:26:30.096 --> 00:26:31.826 A:middle
or soft the player
taps the button.

534
00:26:32.436 --> 00:26:35.976 A:middle
And please remember
to tell the player

535
00:26:35.976 --> 00:26:38.016 A:middle
when you're using
pressure-sensitive nature

536
00:26:38.196 --> 00:26:39.076 A:middle
of the controls.

537
00:26:39.326 --> 00:26:41.696 A:middle
Nothing's worse than me
playing a soccer game for a week

538
00:26:42.156 --> 00:26:45.596 A:middle
and seeing all my shots fly
over the net hard and fast only

539
00:26:45.596 --> 00:26:48.196 A:middle
to realize sometime
in the future, "Oh,

540
00:26:48.446 --> 00:26:51.766 A:middle
they're actually wanting
me to use a little nuance

541
00:26:51.766 --> 00:26:54.616 A:middle
when I'm playing the game, and
I need to use a softer touch."

542
00:26:55.176 --> 00:27:00.646 A:middle
And that relates to how are
you going to be a good teacher

543
00:27:00.896 --> 00:27:02.226 A:middle
of your controls to your player?

544
00:27:03.006 --> 00:27:06.486 A:middle
What you see on screen
here, a visual overlay

545
00:27:06.896 --> 00:27:10.296 A:middle
that is a reference for players
to know what game inputs do what

546
00:27:10.296 --> 00:27:12.616 A:middle
in your game, is a
great starting point.

547
00:27:14.516 --> 00:27:17.706 A:middle
But, we want to be
not just a teacher,

548
00:27:17.706 --> 00:27:19.666 A:middle
but we want to be
a good teacher.

549
00:27:20.716 --> 00:27:22.396 A:middle
So let's look at what
Leo's Fortune does.

550
00:27:23.096 --> 00:27:24.296 A:middle
This is the opening level.

551
00:27:24.296 --> 00:27:25.636 A:middle
I've dropped into game play.

552
00:27:26.056 --> 00:27:29.256 A:middle
And the first thing I see is a
little floating icon over top

553
00:27:29.446 --> 00:27:32.046 A:middle
that suggests I press left
and right on the D-pad.

554
00:27:32.656 --> 00:27:34.236 A:middle
This is great for a
number of reasons.

555
00:27:34.436 --> 00:27:36.036 A:middle
It keeps me in the experience.

556
00:27:36.206 --> 00:27:37.746 A:middle
The game has not paused.

557
00:27:37.746 --> 00:27:38.976 A:middle
I don't have any overlays.

558
00:27:39.666 --> 00:27:41.556 A:middle
And I can move the
character back

559
00:27:41.556 --> 00:27:43.846 A:middle
and forth while this is
onscreen the entire time.

560
00:27:44.676 --> 00:27:46.846 A:middle
It's iconic and it
allows the player

561
00:27:46.846 --> 00:27:48.216 A:middle
to progress at their own pace.

562
00:27:48.846 --> 00:27:49.936 A:middle
And it's out of the way.

563
00:27:50.236 --> 00:27:52.556 A:middle
It's down in the terrain where
it's not blocking my view.

564
00:27:54.096 --> 00:27:55.936 A:middle
After playing with
that for a little bit,

565
00:27:55.936 --> 00:27:58.756 A:middle
I come to the first portion of
the level where I need to jump.

566
00:27:58.856 --> 00:28:03.086 A:middle
And again, in a similar fashion,
they kindly and gently suggest

567
00:28:03.126 --> 00:28:04.336 A:middle
that I press the A button.

568
00:28:04.856 --> 00:28:09.386 A:middle
Now important to note here also,
is they're not overwhelming me

569
00:28:09.386 --> 00:28:12.146 A:middle
at the start with all the
controls for the entire game.

570
00:28:12.606 --> 00:28:14.656 A:middle
They're introducing it
in piecemeal fashion

571
00:28:14.656 --> 00:28:17.706 A:middle
so that I can understand
it, practice it

572
00:28:17.906 --> 00:28:21.626 A:middle
and then learn the next step.

573
00:28:21.756 --> 00:28:22.076 A:middle
All right.

574
00:28:22.076 --> 00:28:23.036 A:middle
Where are we in the talk?

575
00:28:23.256 --> 00:28:25.356 A:middle
I've given you an overview
of game controllers.

576
00:28:26.296 --> 00:28:28.576 A:middle
We know which controllers
are connected to our system.

577
00:28:28.576 --> 00:28:30.406 A:middle
We know how to read
the controller inputs.

578
00:28:30.856 --> 00:28:33.706 A:middle
So now it's time to talk
about what's new in iOS 8.

579
00:28:34.916 --> 00:28:36.036 A:middle
And I'm happy to tell you

580
00:28:36.036 --> 00:28:39.096 A:middle
about a brand new feature
called Controller Forwarding.

581
00:28:39.696 --> 00:28:43.046 A:middle
This allows your game controller
with the snapped-in iPhone

582
00:28:43.196 --> 00:28:44.966 A:middle
to be used as a wireless
controller

583
00:28:45.146 --> 00:28:49.336 A:middle
to control another device
like an iPad or a MacBook Air.

584
00:28:49.836 --> 00:28:52.276 A:middle
This works over Bluetooth
and Wi-Fi.

585
00:28:52.316 --> 00:28:54.876 A:middle
And Bluetooth devices
-- or sorry --

586
00:28:54.876 --> 00:28:56.836 A:middle
the two devices need
to be signed

587
00:28:56.836 --> 00:28:58.086 A:middle
into the same iCloud account.

588
00:28:58.966 --> 00:29:01.166 A:middle
Since this is a new
feature, let me walk you

589
00:29:01.226 --> 00:29:02.876 A:middle
through the flow
of what happens.

590
00:29:05.736 --> 00:29:08.706 A:middle
So we've installed
the game on the iPad.

591
00:29:08.706 --> 00:29:11.226 A:middle
It is not installed on our
phone in the controller.

592
00:29:11.836 --> 00:29:14.326 A:middle
We start playing it.

593
00:29:14.326 --> 00:29:16.476 A:middle
And then through the
magic of continuity,

594
00:29:16.746 --> 00:29:19.936 A:middle
a little gamepad
icon is displayed

595
00:29:19.936 --> 00:29:21.676 A:middle
in the lower corner
of the lock screen.

596
00:29:22.506 --> 00:29:23.966 A:middle
The player swipes up on that

597
00:29:23.966 --> 00:29:26.886 A:middle
and a wireless connection
is established.

598
00:29:28.206 --> 00:29:32.616 A:middle
And all the controller events
are forwarded wirelessly

599
00:29:32.616 --> 00:29:37.796 A:middle
and automatically to the gamepad
-- or to the iPad, sorry.

600
00:29:37.966 --> 00:29:41.956 A:middle
Now, which of this do you
have to take responsibility

601
00:29:42.026 --> 00:29:43.226 A:middle
for and program yourself?

602
00:29:44.936 --> 00:29:45.936 A:middle
Absolutely nothing.

603
00:29:46.636 --> 00:29:49.566 A:middle
As long you're calling
startWirelessController

604
00:29:49.566 --> 00:29:52.856 A:middle
DiscoveryWith CompletionHandler,
all this happens for free.

605
00:29:53.556 --> 00:29:56.816 A:middle
And the beauty is that
the controller appears

606
00:29:56.816 --> 00:29:58.606 A:middle
as any other in the framework.

607
00:29:59.076 --> 00:30:00.876 A:middle
You can read the button
presses off of it.

608
00:30:02.016 --> 00:30:02.936 A:middle
You can find out when

609
00:30:02.936 --> 00:30:04.706 A:middle
that controller connects
and disconnects.

610
00:30:05.286 --> 00:30:08.246 A:middle
You can query whether it's
an extended controller

611
00:30:08.246 --> 00:30:09.366 A:middle
or a standard controller.

612
00:30:10.366 --> 00:30:11.076 A:middle
It just works.

613
00:30:13.136 --> 00:30:17.506 A:middle
Now we figured since phones have
accelerometers and gyroscopes,

614
00:30:18.686 --> 00:30:21.246 A:middle
why don't we go ahead and send
that information along, too.

615
00:30:22.316 --> 00:30:26.316 A:middle
So this way, if your game
supports motion control

616
00:30:26.316 --> 00:30:30.936 A:middle
and game controllers, you don't
need to capture that information

617
00:30:30.936 --> 00:30:34.106 A:middle
and set up a side communication
channel and serialize

618
00:30:34.106 --> 00:30:35.536 A:middle
and de-serialize the data

619
00:30:35.536 --> 00:30:37.456 A:middle
and then synchronize
it on the other end.

620
00:30:37.796 --> 00:30:39.106 A:middle
You don't have to worry
about any of that.

621
00:30:39.106 --> 00:30:40.106 A:middle
We take care of that for you.

622
00:30:40.426 --> 00:30:44.506 A:middle
And all this is found in a new
profile we're calling Motion.

623
00:30:45.616 --> 00:30:48.696 A:middle
Motion is of the
class type GCMotion.

624
00:30:48.896 --> 00:30:50.806 A:middle
So let's look at
what that gives us.

625
00:30:53.226 --> 00:30:58.096 A:middle
Here we have four properties,
gravity, user acceleration,

626
00:30:58.526 --> 00:31:00.836 A:middle
attitude and rotation rate.

627
00:31:02.006 --> 00:31:04.356 A:middle
Now these are probably very
familiar to those of you

628
00:31:04.356 --> 00:31:05.646 A:middle
who have used Core
Motion before.

629
00:31:06.716 --> 00:31:09.786 A:middle
Let's look at each of these
in a little more detail.

630
00:31:10.196 --> 00:31:11.136 A:middle
First: gravity.

631
00:31:13.276 --> 00:31:15.756 A:middle
Gravity is type GCAcceleration.

632
00:31:16.146 --> 00:31:20.036 A:middle
And it returns a vector
oriented in the direction

633
00:31:20.036 --> 00:31:22.026 A:middle
in which gravity is
pulling the device.

634
00:31:23.106 --> 00:31:24.476 A:middle
The units are in G's.

635
00:31:25.596 --> 00:31:29.016 A:middle
And so if the device is
lying flat on a table

636
00:31:29.476 --> 00:31:33.476 A:middle
with the screen facing up, this
vector will return you a value

637
00:31:33.476 --> 00:31:37.196 A:middle
of 0, 0, negative 1
because gravity is pointing

638
00:31:37.196 --> 00:31:41.726 A:middle
in the exact same direction
as the negative zAxis.

639
00:31:41.846 --> 00:31:43.376 A:middle
Next we have userAcceleration.

640
00:31:44.066 --> 00:31:48.596 A:middle
This is used to find out
inertial acceleration

641
00:31:48.596 --> 00:31:50.136 A:middle
when the player is
shaking the controller.

642
00:31:51.626 --> 00:31:52.896 A:middle
It excludes gravity.

643
00:31:52.896 --> 00:31:55.906 A:middle
And the units are also in G's.

644
00:31:56.356 --> 00:31:59.396 A:middle
So in the same scenario, when
the phone is at rest on a table,

645
00:31:59.396 --> 00:32:01.806 A:middle
the acceleration
will be 0, 0, 0.

646
00:32:02.406 --> 00:32:05.536 A:middle
We also have attitude.

647
00:32:06.336 --> 00:32:10.106 A:middle
This allows you to know the
3D orientation of the device.

648
00:32:10.556 --> 00:32:14.626 A:middle
And from that, you can determine
the yaw, the pitch and the roll

649
00:32:14.626 --> 00:32:17.116 A:middle
of the device, if that's
important for your game.

650
00:32:17.996 --> 00:32:19.556 A:middle
Lastly we have rotation rate.

651
00:32:20.136 --> 00:32:24.376 A:middle
This tells you how the phone is
being spun and on which axis.

652
00:32:25.346 --> 00:32:27.516 A:middle
And the units here are
in radians per second.

653
00:32:27.866 --> 00:32:32.016 A:middle
Now, at a high level,
you're going to want

654
00:32:32.016 --> 00:32:33.516 A:middle
to organize your code like this.

655
00:32:34.476 --> 00:32:37.786 A:middle
First you check the
motionProfile on the controller

656
00:32:37.986 --> 00:32:39.306 A:middle
and whether or not it's nil.

657
00:32:39.866 --> 00:32:43.076 A:middle
If it's non-nil, that means
our controller supports motion.

658
00:32:43.806 --> 00:32:45.926 A:middle
And we go ahead and use that.

659
00:32:46.796 --> 00:32:49.286 A:middle
Otherwise, we use
motion from the device.

660
00:32:49.826 --> 00:32:52.456 A:middle
Now, I'd like to
draw your attention

661
00:32:52.456 --> 00:32:55.066 A:middle
to the overall structure
of this if-else statement.

662
00:32:55.146 --> 00:33:00.466 A:middle
In our example, our iPad
was running the game.

663
00:33:01.246 --> 00:33:04.256 A:middle
And the iPad has
motion capabilities.

664
00:33:04.876 --> 00:33:07.566 A:middle
But we don't want to use
those motion capabilities

665
00:33:07.566 --> 00:33:09.926 A:middle
because that device
is just sitting there

666
00:33:09.926 --> 00:33:12.756 A:middle
on the table while we
play with our phone.

667
00:33:12.896 --> 00:33:15.246 A:middle
We want to use the phone's
motion capabilities.

668
00:33:15.726 --> 00:33:22.216 A:middle
Hence, we prioritize
that if it exists.

669
00:33:22.336 --> 00:33:23.676 A:middle
A few notes as well.

670
00:33:24.356 --> 00:33:27.826 A:middle
These axes you see drawn on
the screen with the iPhone,

671
00:33:28.086 --> 00:33:30.706 A:middle
they move with the
phone as it moves.

672
00:33:31.266 --> 00:33:37.896 A:middle
So, what in this orientation has
the positive Y vector pointing

673
00:33:37.896 --> 00:33:42.356 A:middle
straight up towards the sky,
when this phone is snapped

674
00:33:42.356 --> 00:33:44.946 A:middle
into a controller and held
in landscape orientation,

675
00:33:46.026 --> 00:33:48.176 A:middle
positive Y is now
pointing to the left.

676
00:33:48.616 --> 00:33:49.846 A:middle
So this is just something
to be aware

677
00:33:49.846 --> 00:33:50.886 A:middle
of as you're coding your game.

678
00:33:51.886 --> 00:33:53.746 A:middle
Also, Motion data
will be jittery.

679
00:33:54.346 --> 00:33:57.136 A:middle
You're going to want to apply
some sort of a filter to this,

680
00:33:57.486 --> 00:34:02.336 A:middle
maybe a running average of
the last x number of frames.

681
00:34:02.676 --> 00:34:05.816 A:middle
Also new for iOS 8 is
Idle Timer behavior.

682
00:34:06.596 --> 00:34:08.196 A:middle
The idle timer is
what governs whether

683
00:34:08.196 --> 00:34:10.606 A:middle
or not the screen turns
off to save battery power.

684
00:34:10.686 --> 00:34:14.176 A:middle
And in iOS 8, this is
handled automatically for you.

685
00:34:14.815 --> 00:34:18.406 A:middle
Playing a game with the gamepad
will keep your screen alive.

686
00:34:19.565 --> 00:34:23.056 A:middle
In iOS 7, you're going to
want to handle this yourself.

687
00:34:23.545 --> 00:34:25.786 A:middle
And if you want to do
that, this is what you use.

688
00:34:25.916 --> 00:34:29.636 A:middle
You set the IdleTimerDisabled
on the UIApplication instance.

689
00:34:30.706 --> 00:34:31.726 A:middle
Now be careful here.

690
00:34:32.036 --> 00:34:36.116 A:middle
You also need to know when
to re-enable the idle timer.

691
00:34:36.116 --> 00:34:38.096 A:middle
And that's out of the
scope of this talk,

692
00:34:38.096 --> 00:34:39.876 A:middle
so please read the
documentation on that.

693
00:34:41.076 --> 00:34:44.976 A:middle
Also of note is that motion
apps need to do this as well.

694
00:34:45.806 --> 00:34:48.106 A:middle
Moving the phone does not
keep the screen alive.

695
00:34:48.255 --> 00:34:52.676 A:middle
And so regardless of which OS
you're on, you have to do this

696
00:34:52.676 --> 00:34:57.726 A:middle
if you're using motion
in your game.

697
00:34:57.946 --> 00:34:58.606 A:middle
All right.

698
00:34:58.606 --> 00:35:01.886 A:middle
Let me talk about a
little bit more guidance.

699
00:35:02.966 --> 00:35:04.686 A:middle
All controllers have
a pause button.

700
00:35:05.476 --> 00:35:08.186 A:middle
So if your game supports
game controllers,

701
00:35:08.766 --> 00:35:10.866 A:middle
you have to implement
a pause button handler.

702
00:35:11.636 --> 00:35:14.186 A:middle
This is found on
controller instances.

703
00:35:14.316 --> 00:35:15.916 A:middle
It's called
controllerPausedHandler.

704
00:35:16.086 --> 00:35:19.786 A:middle
And whenever this is called you
want to treat it as a toggle.

705
00:35:19.786 --> 00:35:20.536 A:middle
So if you're in the middle

706
00:35:20.536 --> 00:35:22.476 A:middle
of active game play,
pause the game.

707
00:35:23.296 --> 00:35:26.476 A:middle
If you're not -- or sorry,
if your game is paused

708
00:35:26.476 --> 00:35:28.026 A:middle
and this is called,
then un-pause.

709
00:35:28.986 --> 00:35:31.376 A:middle
If you're in a context where
pausing doesn't make sense,

710
00:35:31.376 --> 00:35:34.456 A:middle
like a main menu, it's entirely
appropriate to do nothing.

711
00:35:36.196 --> 00:35:37.976 A:middle
Also: Player Indicator LEDs.

712
00:35:38.816 --> 00:35:42.896 A:middle
Always set the -- sorry,
always set the playerIndex

713
00:35:43.076 --> 00:35:45.796 A:middle
on the controller whenever
you find a controller

714
00:35:45.796 --> 00:35:46.766 A:middle
and are about to use it.

715
00:35:47.356 --> 00:35:50.126 A:middle
This gives players feedback that
the controller is recognized

716
00:35:50.126 --> 00:35:51.476 A:middle
by the game and being used.

717
00:35:52.106 --> 00:35:54.016 A:middle
So in a single player
game, it's as easy

718
00:35:54.016 --> 00:35:55.336 A:middle
as checking the player index.

719
00:35:56.086 --> 00:35:58.476 A:middle
If it's unset, as denoted

720
00:35:58.476 --> 00:36:02.596 A:middle
by this handy flag called
GCControllerPlayerIndexUnset,

721
00:36:02.896 --> 00:36:05.006 A:middle
then go ahead and set
the playerIndex to 0.

722
00:36:05.886 --> 00:36:07.496 A:middle
This is a zero-based index.

723
00:36:07.646 --> 00:36:10.096 A:middle
So this will light up the
first LED on the control pad.

724
00:36:10.226 --> 00:36:14.766 A:middle
Now let's talk about
multiple-controller games.

725
00:36:17.126 --> 00:36:20.916 A:middle
In all of my examples, I'm
calling self.myController.

726
00:36:21.496 --> 00:36:24.666 A:middle
Well, when you have a
multi-player split-screen game,

727
00:36:25.346 --> 00:36:28.646 A:middle
or a game where players
are sharing the same view,

728
00:36:28.646 --> 00:36:30.896 A:middle
you're going to have multiple
controllers, so keep track

729
00:36:30.896 --> 00:36:33.046 A:middle
of them with an array --
myController is plural.

730
00:36:33.606 --> 00:36:36.716 A:middle
And you want to make sure
to set the playerIndex

731
00:36:36.716 --> 00:36:37.856 A:middle
for all the controllers.

732
00:36:38.356 --> 00:36:39.856 A:middle
And I'll show you how
to do that momentarily.

733
00:36:41.326 --> 00:36:45.686 A:middle
Also, consider which controllers
you allow to navigate menus.

734
00:36:45.946 --> 00:36:48.786 A:middle
It can be very confusing if you
have multiple players all trying

735
00:36:48.786 --> 00:36:51.286 A:middle
to navigate a menu at the same
time competing with each other.

736
00:36:51.656 --> 00:36:53.176 A:middle
In that case it may
be appropriate

737
00:36:53.416 --> 00:36:55.626 A:middle
to let only Player
1 control the menus.

738
00:36:57.156 --> 00:36:59.956 A:middle
Also, think about what
a disconnection means

739
00:36:59.956 --> 00:37:01.856 A:middle
in the context of a
multi-player game.

740
00:37:02.556 --> 00:37:04.876 A:middle
In some games like a
one-on-one tennis match,

741
00:37:05.426 --> 00:37:08.356 A:middle
game play cannot proceed
without the second player.

742
00:37:08.406 --> 00:37:11.106 A:middle
And so in that case,
we pause the game.

743
00:37:12.396 --> 00:37:15.876 A:middle
Other types of games with live
drop-in/drop-out game play,

744
00:37:16.626 --> 00:37:21.356 A:middle
can proceed with game play as
players connect and disconnect.

745
00:37:21.566 --> 00:37:23.446 A:middle
So in that case, you
don't necessarily need

746
00:37:23.446 --> 00:37:24.416 A:middle
to pause the game play.

747
00:37:24.696 --> 00:37:25.356 A:middle
It can proceed.

748
00:37:25.996 --> 00:37:28.026 A:middle
So take whatever action is
appropriate for your game.

749
00:37:28.726 --> 00:37:30.466 A:middle
Now let's look at a code sample.

750
00:37:30.466 --> 00:37:33.086 A:middle
Here we are back in our
friend setupControllers.

751
00:37:34.266 --> 00:37:36.876 A:middle
And we're looping over every
controller in our array.

752
00:37:37.396 --> 00:37:40.346 A:middle
And for each one of those we're
checking if the index is unset.

753
00:37:41.066 --> 00:37:43.856 A:middle
If we find even one
controllerIndex that's unset,

754
00:37:43.926 --> 00:37:45.796 A:middle
we display a player
picker to the UI.

755
00:37:46.566 --> 00:37:49.136 A:middle
This allows them to choose which
character they are in the game

756
00:37:49.446 --> 00:37:51.066 A:middle
or to know which
quadrant they're in.

757
00:37:51.886 --> 00:37:54.676 A:middle
And within there, we're
going to set the playerIndex

758
00:37:54.846 --> 00:37:57.046 A:middle
so that the players know
what they're controlling

759
00:37:57.126 --> 00:37:59.386 A:middle
on the screen.

760
00:37:59.446 --> 00:38:01.206 A:middle
Now another piece
of design guidance

761
00:38:01.206 --> 00:38:02.006 A:middle
that I'd like to give you...

762
00:38:02.196 --> 00:38:06.086 A:middle
Very important: respond to
game controller inputs early.

763
00:38:06.656 --> 00:38:10.016 A:middle
When a player snaps in
a controller and taps

764
00:38:10.016 --> 00:38:11.886 A:middle
and launches your game
from a home screen,

765
00:38:12.646 --> 00:38:13.796 A:middle
what is the first thing they do?

766
00:38:14.396 --> 00:38:15.876 A:middle
They start mashing
the buttons, right?

767
00:38:15.876 --> 00:38:17.756 A:middle
They start pressing
the A button.

768
00:38:17.756 --> 00:38:19.106 A:middle
They start moving the D-pad.

769
00:38:19.366 --> 00:38:21.596 A:middle
They want to see if your game
supports game controllers.

770
00:38:22.156 --> 00:38:24.456 A:middle
And every response you make

771
00:38:24.996 --> 00:38:28.946 A:middle
or response your game doesn't
make communicates something

772
00:38:28.946 --> 00:38:29.576 A:middle
to the players.

773
00:38:30.116 --> 00:38:33.456 A:middle
And responding early
tells players, yes,

774
00:38:33.636 --> 00:38:35.286 A:middle
this game supports
game controllers.

775
00:38:36.146 --> 00:38:40.566 A:middle
Now splash screens, introductory
cinematics and the main menu

776
00:38:40.566 --> 00:38:45.006 A:middle
at the latest are great
opportunities to respond

777
00:38:45.006 --> 00:38:46.306 A:middle
to controller inputs early.

778
00:38:46.936 --> 00:38:51.806 A:middle
The longer you wait and the
deeper a player has to get

779
00:38:51.806 --> 00:38:54.866 A:middle
into your game to discover the
game controller integration,

780
00:38:55.336 --> 00:38:57.956 A:middle
the more likely they
are to miss-assume

781
00:38:58.146 --> 00:39:00.086 A:middle
that this game doesn't even
support game controllers

782
00:39:00.436 --> 00:39:02.946 A:middle
and unplug their controller
and just use native inputs,

783
00:39:03.086 --> 00:39:04.946 A:middle
missing all the hard work
you put into your game play.

784
00:39:05.236 --> 00:39:08.776 A:middle
Let's look at what
Leo's Fortune does.

785
00:39:09.416 --> 00:39:10.506 A:middle
So the game launches.

786
00:39:10.606 --> 00:39:12.226 A:middle
It starts off with
the splash screen

787
00:39:12.226 --> 00:39:13.426 A:middle
and introductory cinematic.

788
00:39:13.426 --> 00:39:18.536 A:middle
And pressing the A button
allows you to skip the rest

789
00:39:18.536 --> 00:39:21.606 A:middle
of that cinematic and jump
straight to the main menu.

790
00:39:22.406 --> 00:39:25.216 A:middle
So right there, within a few
seconds of launching the app,

791
00:39:26.166 --> 00:39:27.596 A:middle
the game has told
the player, yes,

792
00:39:27.676 --> 00:39:29.176 A:middle
this game supports
game controllers.

793
00:39:30.776 --> 00:39:33.396 A:middle
Now, at the main menu,
and this is really slick,

794
00:39:33.396 --> 00:39:37.296 A:middle
only when a game controller's
attached do the green portions

795
00:39:37.296 --> 00:39:41.736 A:middle
of the buttons glow,
telling you which button

796
00:39:41.736 --> 00:39:43.166 A:middle
on the screen is active.

797
00:39:44.186 --> 00:39:46.496 A:middle
By using the D-pad
and navigating over,

798
00:39:47.276 --> 00:39:49.476 A:middle
another button begins
glowing instead telling you

799
00:39:49.476 --> 00:39:50.716 A:middle
that that's the active button.

800
00:39:51.236 --> 00:39:54.266 A:middle
So once again, the game
is confirming now, yes,

801
00:39:54.456 --> 00:39:55.926 A:middle
this game supports
game controllers.

802
00:39:56.806 --> 00:39:59.986 A:middle
And the player is highly
likely to enter game play

803
00:39:59.986 --> 00:40:01.686 A:middle
and enjoy the experience
with the controller.

